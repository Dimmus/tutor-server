class Tasks::CourseTimeZoneChanged
  lev_routine

  uses_routine CourseMembership::GetCourseRoles, as: :get_course_roles
  uses_routine Tasks::GetTasks, as: :get_tasks

  protected

  def exec(course:, old_time_zone_name:, new_time_zone_name:)
    return if old_time_zone_name == new_time_zone_name

    @old_time_zone = ActiveSupport::TimeZone[old_time_zone_name]
    @new_time_zone = ActiveSupport::TimeZone[new_time_zone_name]

    # Update tasking plans; could just query tasking plans directly, but we also
    # want to lock task plans so that we don't get simultaneous updates from saving
    # or publishing plans.

    task_plans = Tasks::Models::TaskPlan.lock.where{owner == course}.includes(:tasking_plans)

    task_plans.each do |task_plan|
      task_plan.tasking_plans.each do |tasking_plan|
        tasking_plan.opens_at = change_time_zone(tasking_plan.opens_at)
        tasking_plan.due_at = change_time_zone(tasking_plan.due_at)
        tasking_plan.save

        transfer_errors_from tasking_plan, {type: :verbatim}, true
      end

      task_plan.touch # makes the lock effective (waiting transactions won't
                      # proceed with stale data)
    end

    # Update existing tasks in this course

    student_roles = run(:get_course_roles, course: course, types: :student).outputs.roles
    entity_tasks = run(:get_tasks, roles: student_roles).outputs.tasks
    tasks = Tasks::Models::Task.lock.where{entity_task_id.in entity_tasks.map(&:id)}

    tasks.find_each do |task|
      task.opens_at = change_time_zone(task.opens_at)
      task.due_at = change_time_zone(task.due_at)
      task.save

      transfer_errors_from task, {type: :verbatim}, true
    end
  end

  def change_time_zone(time)
    DateTimeUtilities.keep_time_change_zone(time, @old_time_zone, @new_time_zone)
  end
end

require 'rails_helper'

RSpec.describe Tasks::CourseTimeZoneChanged, type: :routine do

  let!(:old_opens_at) { Chronic.parse("2016-07-01 17:01:02 -0700").to_datetime }
  let!(:old_due_at)   { Chronic.parse("2016-07-02 17:01:02 -0700").to_datetime }
  let!(:period)       { ::CreatePeriod[course: Entity::Course.create!] }
  let!(:student)      { FactoryGirl.create(:user) }
  let!(:student_role) { AddUserAsPeriodStudent[user: student, period: period] }
  let!(:task_plan)    { FactoryGirl.create :tasked_task_plan, owner: period.course }
  let!(:tasking_plan) { task_plan.tasking_plans.first.tap do |tp|
                          tp.opens_at = old_opens_at
                          tp.due_at = old_due_at
                          tp.save
                        end }
  let!(:task)         { FactoryGirl.create :tasks_task, opens_at: old_opens_at, due_at: old_due_at }
  let!(:not_due_task) { FactoryGirl.create :tasks_task, due_at: nil }

  before(:each) do
    [task, not_due_task].each do |tt|
      FactoryGirl.create :tasks_tasking, role: student_role, task: tt.entity_task
    end
  end

  it 'changes task plan and task times' do
    described_class[course: period.course,
                    old_time_zone_name: "Pacific Time (US & Canada)",
                    new_time_zone_name: "Central Time (US & Canada)"]

    tasking_plan.reload
    task.reload

    new_opens_at = Chronic.parse("2016-07-01 17:01:02 -0500").to_datetime
    new_due_at = Chronic.parse("2016-07-02 17:01:02 -0500").to_datetime

    expect(tasking_plan.opens_at).to eq new_opens_at
    expect(tasking_plan.due_at).to eq new_due_at
    expect(task.opens_at).to eq new_opens_at
    expect(task.due_at).to eq new_due_at
    expect(not_due_task.due_at).to be_nil
  end

end

# Add this to the model spec?
        it "can be written with string containing date of form YYYY-MM-DDTHH:MM:SS" do
           consume(input: {field => standard_date_time_str}, to: tasking_plan, time_zone: central_time)
           expect(tasking_plan).to have_received("#{field}=").with(standard_date_time)
         end

         it "time_zone is ignored (upper edge)" do
           pacific_date_time = pacific_time.parse("#{standard_date_str}T23:59:59")
           central_date_time = central_time.parse("#{standard_date_str}T23:59:59")

           consume(input: {field => pacific_date_time.to_s}, time_zone: central_time)

           expect(tasking_plan).to have_received("#{field}=").with(central_date_time)
         end

         it "time_zone is ignored (lower edge)" do
           pacific_date_time = pacific_time.parse("#{standard_date_str}T00:00:00")
           central_date_time = central_time.parse("#{standard_date_str}T00:00:00")

           consume(input: {field => pacific_date_time.to_s}, time_zone: central_time)

           expect(tasking_plan).to have_received("#{field}=").with(central_date_time)
         end

         it "DST is honored" do
           consume(input: {field => daylight_date_time_str.to_s}, time_zone: central_time)
           expect(tasking_plan).to have_received("#{field}=").with(daylight_date_time)
         it "can be written" do
           consume(input: {field => date_time_str}, to: tasking_plan)
           expect(tasking_plan).to have_received("#{field}=").with(date_time_str)
          end
        end
      end
    end

   # A helper for reading input (json or hash) into a TaskingPlan.  Reflects what happens
   # in the task plan controller (has the same `use_zone` wrapping)
   def consume(input:, to: tasking_plan, time_zone:)
     Time.use_zone(time_zone) do
       described_class.new(to).from_json(
         case input
         when String
           input
         when Hash
           input.to_json
         else
           raise StandardError
         end
       )
     end


   context 'when reading time strings in zones' do
     it 'reads central time without string time zone info' do
       datetime = described_class.from_string(datetime_string: "12/25/16 7:00", time_zone: central_time)
       expect(datetime.zone).to eq "CST"
       expect(datetime.to_s).to eq "2016-12-25 07:00:00 -0600"
     end

     it 'reads pacific time and ignores string time zone offset info' do
       datetime = described_class.from_string(datetime_string: "12/25/16 7:00 -0500", time_zone: pacific_time)
       expect(datetime.zone).to eq "PST"
       expect(datetime.to_s).to eq "2016-12-25 07:00:00 -0800"
     end

     it 'reads pacific time and ignores string time zone name info' do
       datetime = described_class.from_string(datetime_string: "12/25/16 7:00 EST", time_zone: pacific_time)
       expect(datetime.zone).to eq "PST"
       expect(datetime.to_s).to eq "2016-12-25 07:00:00 -0800"
     end

     it 'ignores time zone info of the form -07' do
       datetime = described_class.from_string(datetime_string: "12/25/16 7:00 -05", time_zone: pacific_time)
       expect(datetime.zone).to eq "PST"
       expect(datetime.to_s).to eq "2016-12-25 07:00:00 -0800"
     end

     it 'ignores time zone info of the form -07:00' do
       datetime = described_class.from_string(datetime_string: "12/25/16 7:00 -05:00", time_zone: pacific_time)
       expect(datetime.zone).to eq "PST"
       expect(datetime.to_s).to eq "2016-12-25 07:00:00 -0800"
     end

     it 'reads w3c time zone format with arbitrary zones applied' do
       reference_time = Time.utc(2007,2,10,20,30,45)
       w3c_time_string = described_class.to_api_s(reference_time)

       datetime = described_class.from_string(datetime_string: w3c_time_string, time_zone: central_time)
       expect(datetime.to_s).to eq "2007-02-10 20:30:45 -0600"

       datetime = described_class.from_string(datetime_string: w3c_time_string, time_zone: pacific_time)
       expect(datetime.to_s).to eq "2007-02-10 20:30:45 -0800"
     end

     it 'raises when asked to not ignore existing zone' do
       expect{
         described_class.from_string(datetime_string: "12/25/16 7:00", time_zone: central_time, ignore_existing_zone: false)
       }.to raise_error(NotYetImplemented)
     end

     it 'does not change Chronic.time_class permanently' do
       begin
         original_chronic_time_class = Chronic.time_class
         wellington = ActiveSupport::TimeZone["Wellington"]
         Chronic.time_class = wellington
         datetime = described_class.from_string(datetime_string: "12/25/16 7:00", time_zone: central_time)
         expect(datetime.to_s).to eq "2016-12-25 07:00:00 -0600"
         expect(Chronic.time_class).to eq wellington
       ensure
         Chronic.time_class = original_chronic_time_class
       end
     end
   end

   describe "keep_time_change_zone" do
     it 'can keep time and change zone with US zones' do
       old_time = Chronic.parse("2016-07-01 17:01:02 -0700").to_datetime

       expect(old_time.zone).to eq "-07:00"
       expect(old_time.hour).to eq 17

       new_time = described_class.keep_time_change_zone(old_time, pacific_time, central_time)

       expect(new_time.zone).to eq "-05:00"
       expect(new_time.hour).to eq 17
     end

     it 'can keep time and change zone when zones change days' do
       old_time = Chronic.parse("2016-07-01 23:59:59 -0500").to_datetime

       new_time = described_class.keep_time_change_zone(old_time, central_time, utc_time)

       expect(new_time.zone).to eq "+00:00"
       expect(new_time.hour).to eq 23
       expect(new_time.day).to eq 1
     end

     it 'can work when zone on original time is not what is intended' do
       old_time = Chronic.parse("2016-07-01 17:01:02 -0500").to_datetime

       new_time = described_class.keep_time_change_zone(old_time, eastern_time, pacific_time)

       expect(new_time.zone).to eq "-07:00"
       expect(new_time.hour).to eq 18
     end

     it 'returns nil for nil input' do
       expect(described_class.keep_time_change_zone(nil, nil, nil)).to eq nil
     end
   end

   def central_time
     ActiveSupport::TimeZone["Central Time (US & Canada)"]
   end

   def pacific_time
     ActiveSupport::TimeZone["Pacific Time (US & Canada)"]
   end

   def eastern_time
     ActiveSupport::TimeZone["Eastern Time (US & Canada)"]
   end

   def utc_time
     ActiveSupport::TimeZone["UTC"]
   end
